#!/usr/bin/env node
/*
Posts a PR comment linking to the latest failed-report artifact (index.html)
Requires:
  - CIRCLECI_TOKEN (read artifacts)
  - GITHUB_TOKEN (repo:public_repo or repo)
Relies on:
  - reports/ci-latest-failed/summary.json uploaded as artifact by this same job
*/

const fs = require('fs');
const path = require('path');

const CIRCLE_TOKEN = process.env.CIRCLECI_TOKEN || '';
// Prefer GH_PR_COMMENT_TOKEN; fallback to legacy names for compatibility
const GH_TOKEN = process.env.GH_PR_COMMENT_TOKEN || process.env.GITHUB_TOKEN || process.env.GH_TOKEN || '';
const SLUG = process.env.CIRCLE_PROJECT_USERNAME && process.env.CIRCLE_PROJECT_REPONAME
  ? `gh/${process.env.CIRCLE_PROJECT_USERNAME}/${process.env.CIRCLE_PROJECT_REPONAME}` : (process.env.CIRCLE_PROJECT_SLUG || '');
const JOB_NUM = process.env.CIRCLE_BUILD_NUM || process.env.CIRCLE_JOB_NUMBER || '';
const PR_URLS = (process.env.CIRCLE_PULL_REQUESTS || process.env.CIRCLE_PULL_REQUEST || '').split(',').map(s=>s.trim()).filter(Boolean);
const SHA = process.env.CIRCLE_SHA1 || '';
const OUTDIR = process.argv[2] || 'reports/ci-latest-failed';
const REPORT_SET_STATUS = process.env.REPORT_SET_STATUS === '1';
const MARKER = '<!-- remix-e2e-report -->';
const STATUS_CONTEXT = 'remix/e2e-report';

function exit(msg) { console.error(`[post-pr-report] ${msg}`); process.exit(2); }
function log(...a){ console.log('[post-pr-report]', ...a); }

if (!CIRCLE_TOKEN) exit('CIRCLECI_TOKEN missing');
if (!GH_TOKEN) exit('GH_PR_COMMENT_TOKEN missing');
if (!SLUG || !JOB_NUM) exit('Missing CircleCI env (slug or job number)');

const summaryPath = path.join(OUTDIR, 'summary.json');
if (!fs.existsSync(summaryPath)) {
  log('summary.json not found; no failures or generator did not run. Skipping.');
  process.exit(0);
}

(async () => {
  const summary = JSON.parse(fs.readFileSync(summaryPath, 'utf8'));
  const failures = Array.isArray(summary.failures) ? summary.failures : [];
  if (!failures.length) {
    log('No failures in summary; skipping PR comment.');
    process.exit(0);
  }

  const { owner, repo } = parseSlug(SLUG);
  const prNumber = await resolvePrNumber(owner, repo, PR_URLS, SHA);
  if (!prNumber) exit('Cannot resolve PR number from env');

  // Find the artifact URL for index.html uploaded by THIS job
  const artifacts = await circle(`/project/${SLUG}/${JOB_NUM}/artifacts`);
  const index = artifacts.items?.find(a => /ci-latest-failed\/index\.html$/.test(a.path));
  if (!index) exit('index.html artifact not found; ensure store_artifacts ran before this step');
  const indexUrl = index.url;

  // Compose comment
  const top = failures.slice(0, 10);
  const list = top.map(f => `- ${escapeMd(f.name)}${f.file ? ` (${escapeMd(f.file)})` : ''}`).join('\n');
  const body = [
    MARKER,
    `❌ E2E failures detected (workflow: ${escapeMd(summary.workflowName || '')})`,
    '',
    `[View HTML report](${indexUrl})`,
    '',
    `Top failing tests (${top.length}/${failures.length}):`,
    list,
    '',
    '_Report generated by CI; artifacts are retained per CircleCI retention settings._'
  ].join('\n');

  // Sticky comment behavior: update if existing, else create
  const existing = await gh(`GET /repos/${owner}/${repo}/issues/${prNumber}/comments?per_page=100`);
  const mine = (existing || []).find(c => typeof c.body === 'string' && c.body.includes(MARKER));
  if (mine && mine.id) {
    await gh(`PATCH /repos/${owner}/${repo}/issues/comments/${mine.id}`, { body });
    log(`Updated sticky PR comment #${mine.id}`);
  } else {
    const created = await gh(`POST /repos/${owner}/${repo}/issues/${prNumber}/comments`, { body });
    log(`Comment posted to PR #${prNumber}: ${indexUrl} (id=${created.id})`);
  }

  // Optional: set commit status pointing to the report
  if (REPORT_SET_STATUS && SHA) {
    const state = failures.length ? 'failure' : 'success';
    const description = failures.length ? `${failures.length} failing E2E test(s)` : 'E2E passed';
    await gh(`POST /repos/${owner}/${repo}/statuses/${SHA}`, {
      state,
      target_url: indexUrl,
      description,
      context: STATUS_CONTEXT
    });
    log(`Set commit status ${STATUS_CONTEXT}: ${state}`);
  }
})().catch(e => { console.error(e); process.exit(1); });

function parseSlug(slug) {
  const m = String(slug).match(/^(?:gh|github)\/([^/]+)\/([^/]+)$/);
  if (!m) exit(`Bad slug: ${slug}`);
  return { owner: m[1], repo: m[2] };
}

async function resolvePrNumber(owner, repo, prUrls, sha) {
  for (const u of prUrls) {
    const m = String(u).trim().match(/\/pull\/(\d+)/);
    if (m) return Number(m[1]);
  }
  if (!sha) return null;
  const res = await gh(`GET /repos/${owner}/${repo}/commits/${sha}/pulls`, null,
    { accept: 'application/vnd.github.groot-preview+json' });
  if (Array.isArray(res) && res[0]?.number) return res[0].number;
  return null;
}

async function circle(pathname) {
  const res = await fetch(`https://circleci.com/api/v2${pathname}`, {
    headers: { 'Circle-Token': CIRCLE_TOKEN }
  });
  if (!res.ok) throw new Error(`CircleCI ${res.status} ${pathname}`);
  return res.json();
}

async function gh(pathname, body, extraHeaders) {
  const [method, endpoint] = pathname.includes(' ') ? pathname.split(' ', 2) : ['GET', pathname];
  const res = await fetch(`https://api.github.com${endpoint}`, {
    method,
    headers: {
      Authorization: `token ${GH_TOKEN}`,
      'Content-Type': 'application/json',
      ...(extraHeaders || {})
    },
    body: body ? JSON.stringify(body) : undefined
  });
  if (!res.ok) {
    const t = await res.text();
    throw new Error(`GitHub ${res.status} ${endpoint}: ${t}`);
  }
  return res.json();
}

function escapeMd(s) {
  return String(s).replace(/[\[\]()`*_~]/g, '\\$&');
}
